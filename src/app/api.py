# src/app/api.py
from dotenv import load_dotenv
load_dotenv()

from pathlib import Path
from typing import Dict, List, Any
from datetime import datetime, timezone # timestamp

from fastapi import FastAPI, File, HTTPException, Request, UploadFile, status
from fastapi.responses import JSONResponse

from .models import (
    QuestionRequest, 
    QAResponse, 
    ConversationalQARequest, 
    ConversationalQAResponse,
    ConversationHistory
)
from .core.agents.graph import run_conversational_qa_flow
from .services.indexing_service import index_pdf_file

app = FastAPI(
    title="Class 12 Multi-Agent RAG Demo",
    description="Demo API with Feature 5: Conversational Memory",
    version="0.2.1",
)

# --- In-Memory Session Store ---
SESSIONS: Dict[str, List[Dict[str, Any]]] = {}
SESSIONS_METADATA: Dict[str, Dict[str, Any]] = {}

@app.exception_handler(Exception)
async def unhandled_exception_handler(request: Request, exc: Exception) -> JSONResponse:
    if isinstance(exc, HTTPException):
        raise exc
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={"detail": "Internal server error"},
    )

# --- Feature 5: Conversational Endpoints ---

@app.post("/qa/conversation", response_model=ConversationalQAResponse)
async def conversational_qa_endpoint(payload: ConversationalQARequest) -> ConversationalQAResponse:
    """Submit a question in a conversational context."""
    
    question = payload.question.strip()
    if not question:
        raise HTTPException(status_code=400, detail="Question cannot be empty.")

    # 1. Retrieve history
    current_history = []
    session_id = payload.session_id

    if session_id and session_id in SESSIONS:
        current_history = SESSIONS[session_id]
    
    # 2. Run the Graph
    result = run_conversational_qa_flow(
        question=question,
        history=current_history,
        session_id=session_id
    )

    # 3. Extract Results
    final_answer = result.get("answer", "I could not generate an answer.")
    final_session_id = result.get("session_id")
    final_context = result.get("context", "")
    
    # NEW: Extract the summary generated by the new node
    final_summary = result.get("conversation_summary", "")

    # 4. Save History
    if final_session_id not in SESSIONS:
        SESSIONS[final_session_id] = []
    
    turn_number = len(SESSIONS[final_session_id]) + 1
    new_turn = {
        "turn": turn_number,
        "question": question,
        "answer": final_answer,
        "context_snippet": final_context[:200] + "...", 
        "timestamp": datetime.now(timezone.utc).isoformat()
    }
    SESSIONS[final_session_id].append(new_turn)

    # 5. Return Response (Include Summary)
    return ConversationalQAResponse(
        answer=final_answer,
        session_id=final_session_id,
        context=final_context,
        conversation_summary=final_summary # <--- Sending to UI
    )

@app.get("/qa/session/{session_id}/history", response_model=ConversationHistory)
async def get_session_history(session_id: str) -> ConversationHistory:
    if session_id not in SESSIONS:
        raise HTTPException(status_code=404, detail="Session not found")
    
    return ConversationHistory(
        session_id=session_id,
        history=SESSIONS[session_id]
    )

# --- Legacy Endpoints ---
@app.post("/qa", response_model=QAResponse)
async def qa_endpoint(payload: QuestionRequest) -> QAResponse:
    result = run_conversational_qa_flow(payload.question)
    return QAResponse(
        answer=result.get("answer", ""),
        context=result.get("context", ""),
    )

@app.post("/index-pdf")
async def index_pdf(file: UploadFile = File(...)) -> dict:
    if file.content_type != "application/pdf":
        raise HTTPException(status_code=400, detail="Only PDF files are supported.")

    upload_dir = Path("data/uploads")
    upload_dir.mkdir(parents=True, exist_ok=True)
    file_path = upload_dir / file.filename
    contents = await file.read()
    file_path.write_bytes(contents)

    chunks_indexed = index_pdf_file(file_path)

    return {
        "filename": file.filename,
        "chunks_indexed": chunks_indexed,
        "message": "PDF indexed successfully.",
    }